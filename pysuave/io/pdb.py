"""
PDB file reader for pySuAVE.

Simplified PDB parser focused on atomic coordinates.
For more complex PDB operations, consider using MDAnalysis or Biopython.

Fortran equivalent: Parts of abre and file reading in funcproc.f90
"""

from pathlib import Path
from typing import List, Optional
import numpy as np

from pysuave.core.types import AtomData
from pysuave.core.constants import MAX_ATOMS


def read_pdb(filepath: str | Path, 
             atom_indices: Optional[np.ndarray] = None) -> List[AtomData]:
    """
    Read atomic coordinates from a PDB file.
    
    Args:
        filepath: Path to the PDB file
        atom_indices: Optional array of atom indices to read (0-indexed).
                     If None, reads all atoms.
        
    Returns:
        List of AtomData objects
        
    Raises:
        FileNotFoundError: If the file doesn't exist
        ValueError: If the file format is invalid
        
    Example:
        >>> atoms = read_pdb("protein.pdb")
        >>> print(f"Read {len(atoms)} atoms")
    """
    filepath = Path(filepath)
    
    if not filepath.exists():
        raise FileNotFoundError(f"Unable to open file {filepath}")
    
    atoms: List[AtomData] = []
    atom_count = 0
    
    # Convert indices to set for O(1) lookup if provided
    selected_indices = set(atom_indices) if atom_indices is not None else None
    
    try:
        with open(filepath, 'r') as f:
            for line in f:
                # Only process ATOM and HETATM records
                if not (line.startswith('ATOM') or line.startswith('HETATM')):
                    continue
                
                # Check if we should read this atom
                if selected_indices is not None and atom_count not in selected_indices:
                    atom_count += 1
                    continue
                
                try:
                    # PDB format specification
                    # ATOM/HETATM records have fixed column positions
                    atom_serial = int(line[6:11].strip())
                    atom_name = line[12:16].strip()
                    res_name = line[17:20].strip()
                    chain_id = line[21:22].strip()
                    res_seq = int(line[22:26].strip())
                    x = float(line[30:38].strip())
                    y = float(line[38:46].strip())
                    z = float(line[46:54].strip())
                    
                    atom = AtomData(
                        x=x,
                        y=y,
                        z=z,
                        n_atom=atom_serial,
                        n_resid=res_seq,
                        atom=atom_name,
                        resid=res_name,
                        ident=chain_id,
                        code=line[0:6].strip()  # ATOM or HETATM
                    )
                    
                    atoms.append(atom)
                    
                except (ValueError, IndexError) as e:
                    # Skip malformed lines
                    print(f"Warning: Skipping malformed line in {filepath}: {line.strip()}")
                    continue
                
                atom_count += 1
                
                if len(atoms) >= MAX_ATOMS:
                    raise ValueError(
                        f"Too many atoms ({len(atoms)}) in {filepath}. "
                        f"Maximum allowed: {MAX_ATOMS}"
                    )
    
    except IOError as e:
        raise IOError(f"Problem reading {filepath}") from e
    
    if not atoms:
        raise ValueError(f"No atoms found in {filepath}")
    
    print(f"Read {len(atoms)} atoms from {filepath.name}")
    
    return atoms


def write_pdb(filepath: str | Path, 
              atoms: List[AtomData],
              title: str = "Generated by pySuAVE",
              box: Optional[tuple[float, float, float]] = None) -> None:
    """
    Write atomic coordinates to a PDB file.
    
    Args:
        filepath: Output file path
        atoms: List of AtomData objects
        title: Title for the PDB file
        box: Optional box dimensions (x, y, z) in Angstroms
    """
    filepath = Path(filepath)
    
    with open(filepath, 'w') as f:
        # Write header
        f.write(f"REMARK {title}\n")
        f.write(f"REMARK Generated by pySuAVE\n")
        
        # Write box dimensions if provided
        if box is not None:
            boxx, boxy, boxz = box
            f.write(f"CRYST1  {boxx:7.2f}  {boxy:7.2f}  {boxz:7.2f}"
                   f"  90.00  90.00  90.00 P  1       1\n")
        
        # Write atoms
        for i, atom in enumerate(atoms, 1):
            # PDB format: fixed-width columns
            line = (
                f"{atom.code:6s}"  # Record type
                f"{atom.n_atom:5d} "  # Atom serial
                f"{atom.atom:>4s}"  # Atom name
                f" "  # Alternate location
                f"{atom.resid:3s} "  # Residue name
                f"{atom.ident:1s}"  # Chain ID
                f"{atom.n_resid:4d}"  # Residue sequence
                f"    "  # Insertion code + spaces
                f"{atom.x:8.3f}"  # X coordinate
                f"{atom.y:8.3f}"  # Y coordinate
                f"{atom.z:8.3f}"  # Z coordinate
                f"  1.00"  # Occupancy
                f"  0.00"  # Temperature factor
                f"\n"
            )
            f.write(line)
        
        f.write("END\n")
    
    print(f"Wrote {len(atoms)} atoms to {filepath}")


def get_box_from_pdb(filepath: str | Path) -> Optional[tuple[float, float, float]]:
    """
    Extract box dimensions from PDB CRYST1 record.
    
    Args:
        filepath: Path to PDB file
        
    Returns:
        Tuple of (x, y, z) box dimensions in Angstroms, or None if not found
    """
    filepath = Path(filepath)
    
    with open(filepath, 'r') as f:
        for line in f:
            if line.startswith('CRYST1'):
                try:
                    a = float(line[6:15].strip())
                    b = float(line[15:24].strip())
                    c = float(line[24:33].strip())
                    return (a, b, c)
                except (ValueError, IndexError):
                    continue
    
    return None
